<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on savchenko.tech</title>
    <link>https://savchenko.tech/tags/java/</link>
    <description>Recent content in java on savchenko.tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 30 May 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://savchenko.tech/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Project Valhalla: Codes Like a Class, Works Like an int</title>
      <link>https://savchenko.tech/posts/valhalla/</link>
      <pubDate>Fri, 30 May 2025 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/valhalla/</guid>
      <description>What is Project Valhalla? When Java applications create many objects, performance suffers significantly. Each object requires memory allocation on the heap, carries overhead from object headers, and forces the garbage collector to work harder. This becomes especially problematic in data-intensive applications where simple data structures like coordinates, colors, or mathematical values are wrapped in heavyweight objects. Project Valhalla is Oracle&amp;rsquo;s ambitious initiative to bring value types to the Java platform. It aims to provide &amp;ldquo;codes like a class, works like an int&amp;rdquo; semantics.</description>
    </item>
    <item>
      <title>Kotlin. Elegance that We Missed in Java</title>
      <link>https://savchenko.tech/posts/springandkotlin/</link>
      <pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/springandkotlin/</guid>
      <description>For me, as a software engineer with experience in Java, Kotlin was definitely the language of interest. It is also JVM language, but promised to be improved, concise, readable and beautiful.&#xA;So, what are the advantages of Kotlin?&#xA;Null safety - null references are detected at compile time.&#xA;Fluency - fluent code is readable and easier (and cheaper) to maintain.&#xA;Coroutines - a great way to implement non-blocking calls and gracefully handle exceptions.</description>
    </item>
    <item>
      <title>Waiting for Loom&#39;s Virtual Threads...</title>
      <link>https://savchenko.tech/posts/loom/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/loom/</guid>
      <description>Since Alan Turing time we came from running one program at a time on bare metal to running millions of java virtual threads. Which is absolutely impressive.&#xA;Why? Why should we care about threads at all? The answer is - performance. Applying concurrency can improve performance in a few ways:&#xA;reducing latency (process one task faster) hiding latency (process another task while waiting) increasing throughput (process more tasks). Current java concurrency implementation is based on the rule that one Java thread equals exactly one OS thread (one-to-one mapping).</description>
    </item>
    <item>
      <title>Pattern Matching in Java</title>
      <link>https://savchenko.tech/posts/patternmatching/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/patternmatching/</guid>
      <description>To reduce duplication (boilerplate) in code pattern matching with if statements and the instanceof operator was introduced with Java version 16.&#xA;Pattern matching is a technique of controlling program flow that only executes a section of code that meets certain criteria.&#xA;Pattern matching with if and instanceOf In code example without pattern matching cast is needed.&#xA;public Integer objectToString(Object object) { if (object instanceof String) { String string = (String) object; return Integer.</description>
    </item>
  </channel>
</rss>
